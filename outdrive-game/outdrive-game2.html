<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Outrun 2.5D Road Scrolling Demo</title>
<style>
  body { margin: 0; background: black; overflow: hidden; }
  canvas { display: block; margin: 0 auto; background: #555; }
</style>
</head>
<body>
<canvas id="roadCanvas" width="800" height="450"></canvas>
<script>
const canvas = document.getElementById('roadCanvas');
const ctx = canvas.getContext('2d');

const roadWidth = 2000;  // World units
const segmentLength = 200; // Length of a segment in world units
const rumbleLength = 3; // Number of segments per rumble strip

const trackLength = segmentLength * 500;

const camHeight = 1000;  // Camera height in world units
const drawDistance = 300; // Number of segments to draw at once

const fieldOfView = 100; // Camera field of view (degrees)
const cameraDepth = 1 / Math.tan((fieldOfView / 2) * Math.PI / 180) * camHeight;

let speed = 200; // Player speed/world units per second
let position = 0; // Player's position on track in world units
let playerX = 0; // lateral position on road (-1 to 1)
let playerZ = camHeight;

const lanes = 3;

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function easeIn(a, b, t) {
  return t * t * (3 - 2 * t) * (b - a) + a;
}

// Road segment class
class Segment {
  constructor(index, curve = 0) {
    this.index = index;
    this.p1 = {}; // World coordinates at start of segment
    this.p2 = {}; // World coordinates at end of segment
    this.curve = curve; // curve of the segment
    this.color = ((Math.floor(index / rumbleLength) % 2) == 0) ? '#6B8E23' : '#7FBF7F';  // Alternate grass color
  }
}

const segments = [];

// Build segments with simple curve pattern
for (let i = 0; i < 500; i++) {
  let curve = 0;
  if (i > 100 && i < 150) curve = 0.5;
  else if (i >= 150 && i < 200) curve = -0.7;
  else if (i >= 300 && i < 350) curve = 0.7;
  else if (i >= 350 && i < 400) curve = -0.4;
  segments.push(new Segment(i, curve));
}

// Initialize segment coordinates
for (let i = 0; i < segments.length; i++) {
  let seg = segments[i];
  seg.p1.world = { x: 0, y: 0, z: i * segmentLength };
  seg.p2.world = { x: 0, y: 0, z: (i + 1) * segmentLength };
}

// Project 3D point to 2D screen coordinates
function project(p, cameraX, cameraY, cameraZ) {
  let dz = p.z - cameraZ;
  let dx = p.x - cameraX;
  let dy = p.y - cameraY;

  let scale = cameraDepth / dz;
  return {
    x: (1 + dx * scale) * canvas.width / 2,
    y: (1 - dy * scale) * canvas.height / 2,
    w: scale * roadWidth * canvas.width / 2
  };
}

// Draw filled polygon helper
function drawPolygon(color, points) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(points[0].x, points.y);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.closePath();
  ctx.fill();
}

// Draw a road segment: grass, rumble, road
function drawSegment(p1, p2, color) {
  // Draw grass
  drawPolygon(color.grass, [
    { x: 0, y: p2.y },
    { x: canvas.width, y: p2.y },
    { x: canvas.width, y: p1.y },
    { x: 0, y: p1.y }
  ]);

  // Draw rumble strips
  drawPolygon(color.rumble, [
    { x: p1.x - p1.w - 20, y: p1.y },
    { x: p1.x - p1.w, y: p1.y },
    { x: p2.x - p2.w, y: p2.y },
    { x: p2.x - p2.w - 20, y: p2.y }
  ]);

  drawPolygon(color.rumble, [
    { x: p1.x + p1.w + 20, y: p1.y },
    { x: p1.x + p1.w, y: p1.y },
    { x: p2.x + p2.w, y: p2.y },
    { x: p2.x + p2.w + 20, y: p2.y }
  ]);

  // Draw road
  drawPolygon(color.road, [
    { x: p1.x - p1.w, y: p1.y },
    { x: p1.x + p1.w, y: p1.y },
    { x: p2.x + p2.w, y: p2.y },
    { x: p2.x - p2.w, y: p2.y }
  ]);
}

// Colors for each segment
function segmentColors(index) {
  let baseGrass = (index % 2 == 0) ? '#356B0B' : '#4C9A2A';
  let baseRumble = (index % 2 == 0) ? '#CCCCCC' : '#FFFFFF';
  let baseRoad = '#696969';
  return {
    grass: baseGrass,
    rumble: baseRumble,
    road: baseRoad
  };
}

// Main render function
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const baseSegmentIndex = Math.floor(position / segmentLength) % segments.length;

  let x = 0; // road lateral offset
  let dx = 0; // curve delta for road

  let maxY = canvas.height;

  for (let n = 0; n < drawDistance; n++) {
    const segIndex = (baseSegmentIndex + n) % segments.length;
    const segment = segments[segIndex];

    // World coordinates for projection with lateral offset by accumulated curve x offset
    segment.p1.world.x = x;
    segment.p2.world.x = x + segment.curve * segmentLength;

    // Project segment start and end points
    segment.p1.screen = project(segment.p1.world, playerX * roadWidth, camHeight, position);
    segment.p2.screen = project(segment.p2.world, playerX * roadWidth, camHeight, position);

    x += segment.curve * segmentLength;

    // Clip segments behind camera or below last segment drawn
    if (segment.p1.screen.y >= maxY || segment.p1.world.z <= position) continue;

    // Draw segment with colors
    const color = segmentColors(segIndex);
    drawSegment(segment.p1.screen, segment.p2.screen, color);

    maxY = segment.p1.screen.y;
  }

  // Draw player car as a simple triangle on the bottom center
  const carW = 30;
  const carH = 50;
  ctx.fillStyle = 'red';
  ctx.beginPath();
  ctx.moveTo(canvas.width / 2, canvas.height - carH);
  ctx.lineTo(canvas.width / 2 - carW / 2, canvas.height);
  ctx.lineTo(canvas.width / 2 + carW / 2, canvas.height);
  ctx.closePath();
  ctx.fill();
}

// Handle user input for lateral movement
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowLeft') playerX -= 0.05;
  if (e.key === 'ArrowRight') playerX += 0.05;

  playerX = Math.max(-1, Math.min(1, playerX));
});

let lastTime = null;
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const delta = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  position += speed * delta;
  position %= trackLength;

  render();

  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
